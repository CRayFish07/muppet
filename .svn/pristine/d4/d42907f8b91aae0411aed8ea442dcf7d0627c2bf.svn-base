1.4版本主要功能点在于根据用户定义的实体类
（1）、自动生成表定义。 （默认情况下，这个功能是关闭的。）
（2）、根据用户修改，自动修改表定义。（默认情况下，这个功能是关闭的。）
	就难点而言，第二功能点更困难，需要考虑太多的细节，而且不同数据库对Sql标准的支持不同，语法也不同。甚至在某种程度上，难度的增加，导致第二功能点			 很大风险。（未考虑的用户修改场景，导致表定义的错误修改）
	就功能而言：第一功能点是最重要的，用户可以不用熟悉DDL语句的情况下，自动生成表定义。也是实现起来相对容易，稳妥的。	第二功能点：功能而言不是很强，用户数据库变更的情况下，首先思考的更多是操作数据库，而不是操作框架去修改数据库，毕竟通过一种媒介，去修改一种东西，会有误差，只要是媒介就是一种适配器，适配器就需要考虑细节，考虑两方面的细节，细节是容易被忽视的，但是却是能致命的。所以即使hibernate这样的框架，我相信这个功能他也不敢轻易实现，轻易保证修改的可靠性。
	
内部原理与难点：
		1.读取xml配置文件，解析获取实体类的包名（StandardResourceConfig） //董浩
		2.加载指定包下的类，保存在映射（Map）中(StandardResourceLoader)  //杨开
		3. 解析指定包下的所有的类，这里的解析主要是指解析实体类上的所有注解，根据框架预定义的各个注解的使用规则，优先顺序
			冲突处理，将解析结果保存起来（ResourceResolver）(Resolver解析分解)//莹莹
		4. 数据库检查，我们做的是对象向数据库表定义的映射，当然需要在解析配置，//仁鹏
		   加载资源，解析分解完毕之后拿着我们解析到的结果跟数据库进行比较
		   这个比较的重任交给了DataBaseCheck以及他的两个内部类（TableCheck,ColumnCheck）,它主要负责检查表是否存在，列是否存在，列的定义是否不同（主要检查，是否主键，是否为空，是否不同，默认值，是否索引，数据类型，数据类型的长度等）
		   如何比较呢？需要调用JDBC的API,有直接调用即可返回结果的，有的需要混合使用。我所说的细节中有四分之一都在这里
		5. Sql语句生成
		   这是最简单的一层，也是最困难的一层，关键在于你怎么实现，
		   如果你想不负责任的实现，那么你就可以实现的简单一点点，如果你想负责任的实现，你一想到使用你框架的程序员，
		   因为你的愚蠢设计和编码不停地加班，而至于癫狂，就手脚发抖，如坐针毡，深深地愧疚，以至于日日分享祷告，
		   还夜夜噩梦缠身，那么你就负责的实现,（负责的程序猿是宁可让自己癫狂，也不让代码的调用者有一丝烦恼的测试猿）
		   这个层主要由Generate接口负责，其下有很多实现类AlterColumnGenerate,AlterAddColumnGenerate,AlterColumnPrimaryKeyGenerate,TableGenerate
		   分别实现生成列修改语句，列添加语句，修改主键语句，表语句生成。
		6.执行生成的Sql语句，通过Statement执行
		7.异常信息的有效反馈，从一开始muppet就把有效的异常反馈放在首位，让调用者清晰为何出现了错误，少打印一些无效的异常信息，这些异常信息，会	干扰程序员对bug位置的判断。
		但是在这个过程里也遇到了相当大的困难，我们定义了InitException，这个异常是所有异常基类，属于运行期异常，不需要显示捕获，但是如果出错，没有遇到异常处理，会导致程序终止。之前的设计基于模板方法模式，在方法调用层次浅的情况下，表现良好，在方法调用层次高于七级，八级之后，会产生混乱，1.4版本对于异常处理提出了更高的要求，对于异常体系的设计也提出了要求，1.4版本会继续优化异常信息反馈
		8。日志信息反馈。在以往的版本中，muppet并没有日志管理，对于输出也是Sysout，System类的公有属性out是一个PrintStream类型静态常量，他的println方法是一个同步方法，对本对象同步，而且本身I/O操作就很费时，在大量调用后，更导致系统性能下降，所以，再上线，之后，应该杜绝一行与业务无关的System.out.println的运行。所以我们封装了一个Logger类，实现简单的输出，方法内有一个boolean参数可以控制日志输出。

		